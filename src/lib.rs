#![allow(unused_unsafe)] // suppress some warnings generated by autocxx

use autocxx::{
    moveit::{MoveRef, New},
    prelude::*,
};

use nalgebra::{Quaternion, Unit};
use std::pin::Pin;

include_cpp!(
    #include "vqf.hpp"

    safety!(unsafe)

    generate_pod!("VQFParams")
    generate_pod!("VQFState")
    generate_pod!("VQFCoefficients")
    generate_pod!("VQF")
);

#[cfg(doc)]
pub mod ffi_doc {
    pub use crate::ffi::*;
}

pub use ffi::vqf_real_t;
// TODO: should we newtype this? maybe.
pub use ffi::VQFParams;

// This could be on an extension trait
fn unwrap_new<T>(obj: impl New<Output = T>) -> T
where
    T: Unpin,
{
    MoveRef::into_inner(Pin::into_inner(moveit!(obj)))
}

impl VQFParams {
    pub fn new_unwrap() -> Self {
        unwrap_new(VQFParams::new())
    }
}

//#[derive(Debug)]
pub struct VQF(ffi::VQF);

//#[derive(Debug)]
// TODO: derive the builder?
pub struct VQFBuilder<'a> {
    gyro_ts: f64,
    accel_ts: Option<f64>,
    mag_ts: Option<f64>,
    params: Option<&'a VQFParams>,
}

impl<'a> VQFBuilder<'a> {
    pub fn new(gyro_ts: f64) -> Self {
        VQFBuilder {
            gyro_ts,
            accel_ts: None,
            mag_ts: None,
            params: None,
        }
    }

    // TODO: allow override after creating builder?
    // pub fn gyro_ts(mut self, gyro_ts: f64) -> Self {
    //     self.gyro_ts = Some(gyro_ts);
    //     self
    // }

    pub fn accel_ts(mut self, accel_ts: f64) -> Self {
        self.accel_ts = Some(accel_ts);
        self
    }

    pub fn mag_ts(mut self, mag_ts: f64) -> Self {
        self.mag_ts = Some(mag_ts);
        self
    }

    pub fn params(mut self, params: &'a VQFParams) -> Self {
        self.params = Some(params);
        self
    }

    pub fn build(self) -> VQF {
        let accel_ts = self.accel_ts.unwrap_or(-1.0);
        let mag_ts = self.mag_ts.unwrap_or(-1.0);
        let res = if let Some(params) = self.params {
            unwrap_new(ffi::VQF::new1(params, self.gyro_ts, accel_ts, mag_ts))
        } else {
            unwrap_new(ffi::VQF::new(self.gyro_ts, accel_ts, mag_ts))
        };

        VQF(res)
    }
}

impl VQF {
    /// (safe) internal helper that gets the inner ffi::VQF wrapped in a Pin.
    fn pin<'a>(&'a mut self) -> Pin<&'a mut ffi::VQF> {
        Pin::new(&mut self.0)
    }
    /// Performs gyroscope update step.
    ///
    /// It is only necessary to call this function directly if gyroscope, accelerometers and magnetometers have
    /// different sampling rates. Otherwise, simply use [`VQF::update_6dof`] or [`VQF::update_9dof`].
    ///
    /// # Arguments
    /// * `measurement` - gyroscope measurement in rad/s
    pub fn update_gyro(&mut self, measurement: &[vqf_real_t; 3]) {
        unsafe {
            // Safety: The C++ method looks like this: void updateGyr(const vqf_real_t gyr[3]);
            //  which should mean that as long as we pass 3 items, we're good.
            self.pin().updateGyr(measurement.as_ptr())
        }
    }

    /// Performs accelerometer update step.
    ///
    /// It is only necessary to call this function directly if gyroscope, accelerometers and magnetometers have
    /// different sampling rates. Otherwise, simply use [`VQF::update_6dof`] or [`VQF::update_9dof`].
    ///
    /// Should be called after [`VQF::update_gyro`] and before [`VQF::update_mag`].
    ///
    /// # Arguments
    /// * `measurement` - accelerometer measurement in m/s²
    pub fn update_accel(&mut self, measurement: &[vqf_real_t; 3]) {
        unsafe {
            // Safety: The C++ method looks like this: void updateAcc(const vqf_real_t acc[3]);
            //  which should mean that as long as we pass 3 items, we're good.
            self.pin().updateAcc(measurement.as_ptr())
        }
    }

    /// Performs magnetometer update step.
    ///
    /// It is only necessary to call this function directly if gyroscope, accelerometers and magnetometers have
    /// different sampling rates. Otherwise, simply use [`VQF::update_6dof`] or [`VQF::update_9dof`].
    ///
    /// Should be called after [`VQF::update_accel`].
    ///
    /// # Arguments
    /// * `measurement` - magnetometer measurement in arbitrary units
    pub fn update_mag(&mut self, measurement: &[vqf_real_t; 3]) {
        unsafe {
            // Safety: The C++ method looks like this: void updateMag(const vqf_real_t acc[3]);
            //  which should mean that as long as we pass 3 items, we're good.
            self.pin().updateMag(measurement.as_ptr())
        }
    }

    /// Performs filter update step for one sample (magnetometer-free).
    /// # Arguments
    /// * `gyro` - gyroscope measurement in rad/s
    /// * `accel` - accelerometer measurement in m/s²
    pub fn update_6dof(&mut self, gyro: &[vqf_real_t; 3], accel: &[vqf_real_t; 3]) {
        unsafe {
            // Safety: The C++ method looks like this: void update(const vqf_real_t gyr[3], const vqf_real_t acc[3]);
            //  which should mean that as long as we pass 3 items for each argument, we're good.
            self.pin().update(gyro.as_ptr(), accel.as_ptr())
        }
    }

    /// Performs filter update step for one sample (with magnetometer measurement).
    /// # Arguments
    /// * `gyro` - gyroscope measurement in rad/s
    /// * `accel` - accelerometer measurement in m/s²
    /// * `mag` - magnetometer measurement in arbitrary units
    pub fn update_9dof(
        &mut self,
        gyro: &[vqf_real_t; 3],
        accel: &[vqf_real_t; 3],
        mag: &[vqf_real_t; 3],
    ) {
        unsafe {
            // Safety: The C++ method looks like this: void update(const vqf_real_t gyr[3], const vqf_real_t acc[3]);
            //  which should mean that as long as we pass 3 items for each argument, we're good.
            self.pin()
                .update1(gyro.as_ptr(), accel.as_ptr(), mag.as_ptr())
        }
    }

    // TODO: update_batch has so many arguments >_>

    /// Returns the angular velocity strapdown integration quaternion
    pub fn get_quat_3d(&self) -> Unit<Quaternion<vqf_real_t>> {
        let mut wxyz_quat = [0.0; 4];
        unsafe {
            // Safety: The C++ method looks like this: void getQuat3D(vqf_real_t out[4]) const;
            //  which should mean that as long as we pass 4 items, we're good.
            self.0.getQuat3D(wxyz_quat.as_mut_ptr());
        }

        // This appears to be normalized within VQF, so I'm not checking it here.
        Unit::new_unchecked(Quaternion::new(
            wxyz_quat[0],
            wxyz_quat[1],
            wxyz_quat[2],
            wxyz_quat[3],
        ))
    }

    /// Returns the 6D (magnetometer-free) orientation quaternion
    pub fn get_quat_6d(&self) -> Unit<Quaternion<vqf_real_t>> {
        let mut wxyz_quat = [0.0; 4];
        unsafe {
            // Safety: The C++ method looks like this: void getQuat6D(vqf_real_t out[4]) const;
            //  which should mean that as long as we pass 4 items, we're good.
            self.0.getQuat6D(wxyz_quat.as_mut_ptr());
        }

        // This appears to be normalized within VQF, so I'm not checking it here.
        Unit::new_unchecked(Quaternion::new(
            wxyz_quat[0],
            wxyz_quat[1],
            wxyz_quat[2],
            wxyz_quat[3],
        ))
    }

    /// Returns the 9D (with magnetometers) orientation quaternion
    pub fn get_quat_9d(&self) -> Unit<Quaternion<vqf_real_t>> {
        let mut wxyz_quat = [0.0; 4];
        unsafe {
            // Safety: The C++ method looks like this: void getQuat9D(vqf_real_t out[4]) const;
            //  which should mean that as long as we pass 4 items, we're good.
            self.0.getQuat9D(wxyz_quat.as_mut_ptr());
        }

        // This appears to be normalized within VQF, so I'm not checking it here.
        Unit::new_unchecked(Quaternion::new(
            wxyz_quat[0],
            wxyz_quat[1],
            wxyz_quat[2],
            wxyz_quat[3],
        ))
    }
}
